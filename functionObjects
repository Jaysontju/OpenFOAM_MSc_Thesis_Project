These are basically small pieces of code that are being executed at every time-step without 
explizitly being linked to the application. 

A functionObject is added to a solver by adding a functions entry in system/controlDictls


To find all of the examples of Function Objects being used in the standard OpenFOAM tutorials, 
run the following command to get a list of tutorial cases that used them: 
find $FOAM_TUTORIALS -name controlDict | xargs grep 'functions' -sl
grep -r functionObjectLibs $FOAM_TUTORIALS

The implementations can be found in
$FOAM_SRC/postProcessing/functionObjects

//https://github.com/OpenFOAM/OpenFOAM-2.3.x/blob/master/src/postProcessing/functionObjects/field/fieldMinMax/fieldMinMax.H

Examples
/*..........................................................................................*/

functions
{
    fieldAverage
    {
        type            fieldAverage;
        functionObjectLibs ("libfieldFunctionObjects.so");
        //resetOnRestart true; //restart the averaging process with the new time
        //resetOnOutput false; //restart the averaging process after each calculation output time
        //enabled         true;
        //outputControl   outputTime;
        //outputInterval 1;
        fields
        (
            T
            {
                mean        on;   //arithmetic mean
                prime2Mean  on;   //prime-squared mean
                base        time; //average over 'time', or 'iteration'
            }
        );
    }
    
    minMax
    {
        type            fieldMinMax;
        functionObjectLibs ( "libfieldFunctionObjects.so" );
        enabled         true;
        write yes; //write min/max data to file
        log yes; //write min/max data to standard output
        mode magnitude;
        //outputControl   outputTime;
        //outputInterval 1;

        fields
        (
            
            T
            U
        );
    }

    volumeTemperature
    {
        type            cellSource;
        functionObjectLibs ("libfieldFunctionObjects.so");

        log             yes;  //write data to standard output
        valueOutput     no; //write the raw output values
        source          all; //all cellZone;
        //sourceName      c0;
        operation       average; //volAverage weightedAverage
        //weightField     alpha1;
        fields
        (
            T
        );
    }

    faceTemperature
    {
        type            faceSource;
        functionObjectLibs ("libfieldFunctionObjects.so");

        log             yes;  //write data to standard output
        valueOutput     no; //write the raw output values
        surfaceFormat   none;
        source          patch; //faceZone patch sampledSurface;
        sourceName      outlet; //inlet outlet fixedWalls;
        operation       average; //areaAverage weightedAverage 
        //weightField     alpha1;
        fields
        (
            T
        );
    }

}

functions
{
    probes
    {
        // Where to load it from
        functionObjectLibs ( "libsampling.so" );

        type            probes;

        // Name of the directory for probe data
        name            probes;

        // Write at same frequency as fields
        outputControl   outputTime;
        outputInterval  1;

        // Fields to be probed
        fields
        (
            p U
        );

        probeLocations
        (
            ( 1e-06 0 0.01 )        // at inlet
            ( 0.21 -0.20999 0.01 )  // at outlet1
            ( 0.21 0.20999 0.01 )   // at outlet2
            ( 0.21 0 0.01 )         // at central block
        );
    }

    streamLines
    {
        type            streamLine;

        // Where to load it from (if not already in solver)
        functionObjectLibs ("libfieldFunctionObjects.so");

        // Output every
        outputControl   outputTime;
        // outputInterval 10;

        setFormat       vtk; //gnuplot;//xmgr;//raw;//jplot;//csv;//ensight;

        // Velocity field to use for tracking.
        UName U;

        // Tracked forwards (+U) or backwards (-U)
        trackForward    true;

        // Names of fields to sample. Should contain above velocity field!
        fields (p k U);

        // Steps particles can travel before being removed
        lifeTime        10000;

        // Number of steps per cell (estimate). Set to 1 to disable subcycling.
        nSubCycle 5;

        // Cloud name to use
        cloudName       particleTracks;

        // Seeding method. See the sampleSets in sampleDict.
        seedSampleSet   uniform;  //cloud;//triSurfaceMeshPointSet;

        uniformCoeffs
        {
            type        uniform;
            axis        x;  //distance;

            start       (-0.0205 0.001  0.00001);
            end         (-0.0205 0.0251 0.00001);
            nPoints     10;
        }
    }

    wallPressure
    {
        type            surfaces;
        functionObjectLibs ("libsampling.so");
        outputControl   outputTime;
        surfaceFormat   raw;
        fields
        (
            p
        );
        interpolationScheme cellPoint;

        surfaces
        (
            walls
            {
                type        patch;
                patches     (walls);
                triangulate false;
            }
        );
    }

}

